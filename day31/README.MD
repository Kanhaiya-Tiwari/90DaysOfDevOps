
# âœ… **Task 1 â€“ my First Dockerfile**

## 1ï¸âƒ£ Create project folder

```bash
mkdir my-first-image
cd my-first-image

## 2ï¸âƒ£ Create Dockerfile

```bash
touch Dockerfile
```

Open it:

```bash
vim Dockerfile
```

Paste:

```dockerfile
FROM ubuntu:latest

RUN apt-get update && apt-get install -y curl

CMD ["echo", "Hello from my custom image!"]
```

---

## 3ï¸âƒ£ Build image

```bash
docker build -t my-ubuntu:v1 .
```

ğŸ‘‰ `.` = current folder = **build context**

---

## 4ï¸âƒ£ Run container

```bash
docker run my-ubuntu:v1
```

âœ… Output:

```
Hello from my custom image!
```

---

## ğŸ§  What happened?

| Line        | Meaning                    |
| ----------- | -------------------------- |
| FROM ubuntu | Base OS                    |
| RUN apt-get | Install curl during build  |
| CMD echo    | Default command at runtime |

---

# âœ… **Task 2 â€“ Dockerfile Instructions**

---

## 1ï¸âƒ£ Create new folder

```bash
mkdir dockerfile-demo
cd dockerfile-demo
```

---

## 2ï¸âƒ£ Create files

```bash
touch Dockerfile
touch app.txt
```

Edit `app.txt`:

```bash
vim app.txt
```

Add:

```
Hello from inside container
```

---

## 3ï¸âƒ£ Dockerfile

```dockerfile
FROM ubuntu:latest

RUN apt-get update && apt-get install -y curl

WORKDIR /app

COPY app.txt .

EXPOSE 8080

CMD ["cat", "app.txt"]
```

---

## 4ï¸âƒ£ Build

```bash
docker build -t demo:v1 .
```

---

## 5ï¸âƒ£ Run

```bash
docker run demo:v1
```

âœ… Output:

```
Hello from inside container
```

---

## ğŸ§  Understand each instruction

| Instruction | Purpose                     |
| ----------- | --------------------------- |
| FROM        | Base image                  |
| RUN         | Executes during build       |
| WORKDIR     | Sets working directory      |
| COPY        | Copy file from host â†’ image |
| EXPOSE      | Documentation only          |
| CMD         | Default runtime command     |

âš ï¸ EXPOSE **does NOT open port automatically**

---

# âœ… **Task 3 â€“ CMD vs ENTRYPOINT**

---

## ğŸ”¹ Case 1: CMD

Dockerfile:

```dockerfile
FROM ubuntu:latest
CMD ["echo", "hello"]
```

Build:

```bash
docker build -t cmd-test .
```

Run:

```bash
docker run cmd-test
```

âœ… Output:

```
hello
```

---

### Override CMD

```bash
docker run cmd-test ls
```

âœ… Output:

```
bin
boot
dev
...
```

ğŸ‘‰ CMD is **replaced**

---

## ğŸ”¹ Case 2: ENTRYPOINT

Dockerfile:

```dockerfile
FROM ubuntu:latest
ENTRYPOINT ["echo"]
```

Build:

```bash
docker build -t entry-test .
```

Run:

```bash
docker run entry-test hello
```

âœ… Output:

```
hello
```

---

### Add arguments

```bash
docker run entry-test hello world
```

âœ… Output:

```
hello world
```

ğŸ‘‰ Arguments are **appended**

---

## ğŸ§  Key Difference

| CMD               | ENTRYPOINT         |
| ----------------- | ------------------ |
| Easily overridden | Harder to override |
| Default behavior  | Main executable    |
| Flexible          | Fixed purpose      |

---

## âœ… When to use?

âœ” **CMD** â†’ default command
âœ” **ENTRYPOINT** â†’ fixed app (nginx, python app)

---

# âœ… **Task 4 â€“ Simple Web App Image**

---

## 1ï¸âƒ£ Create folder

```bash
mkdir my-website
cd my-website
```

---

## 2ï¸âƒ£ index.html

```bash
touch index.html
```

Edit:

```html
<h1>Hello from Docker Website ğŸš€</h1>
```

---

## 3ï¸âƒ£ Dockerfile

```dockerfile
FROM nginx:alpine

COPY index.html /usr/share/nginx/html/

EXPOSE 80
```

---

## 4ï¸âƒ£ Build

```bash
docker build -t my-website:v1 .
```

---

## 5ï¸âƒ£ Run

```bash
docker run -p 8080:80 my-website:v1
```

Open browser:

```
http://localhost:8080
```

âœ… Your page appears

---

## ğŸ§  Why it works?

Nginx serves from:

```
/usr/share/nginx/html/
```

---

# âœ… **Task 5 â€“ .dockerignore**

---

## 1ï¸âƒ£ Create file

```bash
touch .dockerignore
```

---

## 2ï¸âƒ£ Add

```
node_modules
.git
*.md
.env
```

---

## ğŸ§  Why important?

Without `.dockerignore`:

âŒ Slow builds
âŒ Large images
âŒ Sensitive data leak

---

## 3ï¸âƒ£ Verify

Build again:

```bash
docker build -t test-ignore .
```

Ignored files NOT sent to Docker daemon.

---

# âœ… **Task 6 â€“ Build Optimization**

---

## ğŸ§ª Observe Cache

Build once:

```bash
docker build -t cache-demo .
```

Rebuild without change:

```bash
docker build -t cache-demo .
```

âœ… â€œUsing cacheâ€

---

## ğŸ”¥ Now change something

Modify Dockerfile:

```dockerfile
CMD ["echo", "Changed"]
```

Rebuild.

ğŸ‘‰ Only last layer rebuilds.

---

## ğŸ§  Why layer order matters?

Docker builds **layer by layer**

Bad order:

```dockerfile
COPY . .
RUN npm install
```

Any code change â†’ reinstall dependencies âŒ

---

Better order:

```dockerfile
COPY package.json .
RUN npm install
COPY . .
```

Dependencies cached âœ…

---

## âœ… Rule of thumb

ğŸ‘‰ **Stable layers first**
ğŸ‘‰ **Changing layers last**



